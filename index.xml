<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Negentropy</title>
    <link>https://chengyayu.github.io/</link>
    <description>Recent content on Negentropy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 22 Apr 2021 13:28:06 +0800</lastBuildDate><atom:link href="https://chengyayu.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Decorator Design Pattern</title>
      <link>https://chengyayu.github.io/posts/decorator-design-pattern/</link>
      <pubDate>Thu, 22 Apr 2021 13:28:06 +0800</pubDate>
      
      <guid>https://chengyayu.github.io/posts/decorator-design-pattern/</guid>
      <description>修饰器模式（Decorator Design Pattern）是一种结构型设计模式。由于目标对象和装饰器遵循同一接口，因此可用装饰来对对象进行无限次的封装。结果对象将获得所有封装器叠加而来的行为。这里的目标对象可以是一个结构，也可以是一个函数。与之相对可以通过结构组合（面向对象编程范式）或者高阶函数（函数式编程范式）的方式实现这个模式。
UML Diagram  Client 为主调方，依赖 Component 接口； Concrete Component 1(2) 是实现了 Component 接口的结构； Decorator 定义了实现契约的“抽象类”：  修饰器必须内嵌一个实现了 Component 接口的实例 修饰器本身必须实现 Compinent 接口   Concrete Decorator 1(2) 是遵循某种契约（Decorator）的结构；  修饰器本身与修饰器持有的实例都实现了同样的接口，所以可以实现对接口的无限封装，以获得叠加的新能力。
Example 1 （面向对象编程范式） Go 实现的版本是通过组合玩法，创建内嵌 Component 实例的 Decorator 结构（本身也实现 Component 接口），来完成对既有接口的包装和扩展。
Question:
香河肉饼准备拓展业务卖披萨饼，暂定 Small 饼底 10 元， Large 饼底 15 元， Cocoa 配料 20 元， Fruit 配料 25 元， 饼底和口味(可叠加)可以随意组合，应如何设计？ Code:
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5type pizza interface { 6	getPrice() int 7} 8 9type SmallCrepes struct{} 10 11func (p *SmallCrepes) getPrice() int { 12	return 10 13} 14 15type LargeCrepes struct{} 16 17func (p *LargeCrepes) getPrice() int { 18	return 15 19} 20 21type CocoaTopping struct { 22	pizza pizza 23} 24 25func (c *CocoaTopping) getPrice() int { 26	pizzaPrice := c.</description>
    </item>
    
    <item>
      <title>Adapter Design Pattern</title>
      <link>https://chengyayu.github.io/posts/adapter-design-pattern/</link>
      <pubDate>Tue, 20 Apr 2021 20:49:46 +0800</pubDate>
      
      <guid>https://chengyayu.github.io/posts/adapter-design-pattern/</guid>
      <description>适配器模式（Adapter Design Pattern）是一种结构型设计模式。把一个结构的一组方法转换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法一起工作的两个结构能够一起工作。对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。
UML Diagram  Client 为主调方，依赖 Target 接口; Target 表示目标接口定义; Adaptee 为一组不兼容 Target 接口定义的接口（被适配的结构）; Adaptor 将 Adaptee 转化成一组符合 Target 接口定义的接口;  适配器模式也可以称为 Wrapper 模式，通过构建（内嵌一个接口不匹配的 Adaptee）Wrapper 结构来对 Adaptee 进行能力转换以实现 Target 接口。由于 Client 的业务逻辑依赖的是抽象（Target 接口）而非具体的结构类型，原本无法与 Client 对接的 Adaptee 经过 Adapter 包装也可以与 Client 对接了。
Example Question：
mac 电脑具备接入 Lightning 插头的能力。 windows 电脑具备接入 USB 插头的能力。 client 希望将 Lightning 插头接入两台电脑，应如何处理？ Code:
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5// 主调方依赖的目标接口 6type computer interface { 7	insertIntoLightningPort() 8} 9 10// 已实现目标接口 11type mac struct{} 12 13func (m *mac) insertIntoLightningPort() { 14	fmt.</description>
    </item>
    
    <item>
      <title>Proxy Design Pattern</title>
      <link>https://chengyayu.github.io/posts/proxy-design-pattern/</link>
      <pubDate>Mon, 19 Apr 2021 19:57:02 +0800</pubDate>
      
      <guid>https://chengyayu.github.io/posts/proxy-design-pattern/</guid>
      <description>代理模式（Proxy Design Pattern）是一种结构型设计模式。在不改变主对象的前提下，通过引入额外的一层来为主对象提供控制和智能访问。
在此模式中，创建一个新的代理类，它实现与主要对象相同的接口。这样可以保证在主对象的实际逻辑之前执行某些行为。
UML Diagram Practical Example </description>
    </item>
    
    <item>
      <title>Functional Options Pattern</title>
      <link>https://chengyayu.github.io/posts/functional-options-pattern/</link>
      <pubDate>Mon, 30 Nov 2020 13:38:02 +0800</pubDate>
      
      <guid>https://chengyayu.github.io/posts/functional-options-pattern/</guid>
      <description>一个 Server 拥有很多配置选项，创建对象时一部分选项需要强制指定，另一部分选项非强制指定，且有缺省值。 如何设计一个对调用方友好的 NewServer 构造函数 API ？
Configuration Problem 例如 Addr 和 Port 是需要强制指定的选项，其他选项非强制指定，且有缺省值，该如何设计 New Server 构造函数呢？
1type Server struct { 2 Addr string 3 Port int 4 Protocol string 5 Timeout time.Duration 6 MaxConns int 7 TLS *tls.Config 8} 我们可以创建一组针对不同情况的构造函数。
1func NewServer(addr string, port int) (*Server, error) { 2 //... 3} 4func NewTLSServer(addr string, port int, tls *tls.Config) (*Server, error) { 5 //... 6} 7func NewServerWithTimeout(addr string, port int, timeout time.</description>
    </item>
    
    <item>
      <title>低层级重构基本手法</title>
      <link>https://chengyayu.github.io/posts/%E4%BD%8E%E5%B1%82%E7%BA%A7%E9%87%8D%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%89%8B%E6%B3%95/</link>
      <pubDate>Thu, 19 Nov 2020 01:08:43 +0800</pubDate>
      
      <guid>https://chengyayu.github.io/posts/%E4%BD%8E%E5%B1%82%E7%BA%A7%E9%87%8D%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%89%8B%E6%B3%95/</guid>
      <description>什么是好代码的特征 评价代码好坏，如同审美，不仅关乎个人品味，而且存在客观标准。 好的代码直接了当，如果需要被修改，能让“修理工”轻易找到修改点，并且快速做出更改，同时不易引入其他错误。 检验标准可以归纳成 ETC（Easy To Change）原则，就是人们是否能轻而易举地修改它。
遗憾的是，我们面对不断变化的业务需求很难一步到位。只能快速实现，时时修缮，以期达到小步快跑的节奏感。
何为重构 在不改变软件可观察行为的前提下，调整其结构。使之无限接近 ETC。
何时重构  预备性重构：添加新功能很费劲 帮助理解的重构：代码看不懂 捡垃圾式重构：代码能看懂，但是烂 长期重构：每次改一点，就算改个名字也是好的 不重构：不需要理解则不必重构  重构的挑战  延缓新功能开发 遗留代码 代码所有权* 测试* 独立系统（数据库）*  尺度大一点
 是不是不需要做架构了？ 无限增加可读性会不会影响性能？  代码坏味道 1 神秘命名
2 重复代码
3 过长函数
4 过长参数列表
5 全局数据
 特征：数据不符合预期的被改变，又找不到变动源头 原因：  不可变：相对安全 可变：作用域范围越大，被影响的概率越大，越难以探测影响源   改进：  封装到一个结构中，提供可以修改其值的方法    6 可变数据
 特征：一个变量拥有不同的语义 原因：  副作用   改进：  将一个（多功能）变量拆分成多个功能单一的变量 将没有副作用的代码和没有副作用的代码拆分开 函数式编程：如果要更新一个数据结构，就返回一份新的数据副本    7 发散式变化</description>
    </item>
    
  </channel>
</rss>
