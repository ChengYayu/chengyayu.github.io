<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on Negentropy</title>
    <link>https://chengyayu.github.io/tags/go/</link>
    <description>Recent content in go on Negentropy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 20 Apr 2021 20:49:46 +0800</lastBuildDate><atom:link href="https://chengyayu.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Adapter Design Pattern</title>
      <link>https://chengyayu.github.io/posts/adapter-design-pattern/</link>
      <pubDate>Tue, 20 Apr 2021 20:49:46 +0800</pubDate>
      
      <guid>https://chengyayu.github.io/posts/adapter-design-pattern/</guid>
      <description>适配器模式（Adapter Design Pattern）是一种结构型设计模式。它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。
UML Diagram  Client 为主调方，依赖 Target 接口 Target 表示目标接口定义 Adaptee 为一组不兼容 Target 接口定义的接口（被适配的类） Adaptor 将 Adaptee 转化成一组符合 Target 接口定义的接口  客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。
Example Question：
mac 电脑具备接入 Lightning 插头的能力。 windows 电脑具备接入 USB 插头的能力。 client 希望将 Lightning 插头接入两台电脑，应如何处理？ Code:
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5// 主调方依赖的目标接口 6type computer interface { 7	insertIntoLightningPort() 8} 9 10// 已实现目标接口 11type mac struct{} 12 13func (m *mac) insertIntoLightningPort() { 14	fmt.</description>
    </item>
    
    <item>
      <title>Proxy Design Pattern</title>
      <link>https://chengyayu.github.io/posts/proxy-design-pattern/</link>
      <pubDate>Tue, 20 Apr 2021 19:57:02 +0800</pubDate>
      
      <guid>https://chengyayu.github.io/posts/proxy-design-pattern/</guid>
      <description>代理模式（Proxy Design Pattern）是一种结构型设计模式。在不改变主对象的前提下，通过引入额外的一层来为主对象提供控制和智能访问。
在此模式中，创建一个新的代理类，它实现与主要对象相同的接口。这样可以保证在主对象的实际逻辑之前执行某些行为。
UML Diagram Practical Example </description>
    </item>
    
    <item>
      <title>Functional Options Pattern</title>
      <link>https://chengyayu.github.io/posts/functional-options-pattern/</link>
      <pubDate>Mon, 30 Nov 2020 13:38:02 +0800</pubDate>
      
      <guid>https://chengyayu.github.io/posts/functional-options-pattern/</guid>
      <description>一个 Server 拥有很多配置选项，创建对象时一部分选项需要强制指定，另一部分选项非强制指定，且有缺省值。 如何设计一个对调用方友好的 NewServer 构造函数 API ？
Configuration Problem 例如 Addr 和 Port 是需要强制指定的选项，其他选项非强制指定，且有缺省值，该如何设计 New Server 构造函数呢？
1type Server struct { 2 Addr string 3 Port int 4 Protocol string 5 Timeout time.Duration 6 MaxConns int 7 TLS *tls.Config 8} 我们可以创建一组针对不同情况的构造函数。
1func NewServer(addr string, port int) (*Server, error) { 2 //... 3} 4func NewTLSServer(addr string, port int, tls *tls.Config) (*Server, error) { 5 //... 6} 7func NewServerWithTimeout(addr string, port int, timeout time.</description>
    </item>
    
  </channel>
</rss>
