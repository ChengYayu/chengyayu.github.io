<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>structural-patterns on Negentropy</title>
    <link>https://chengyayu.github.io/tags/structural-patterns/</link>
    <description>Recent content in structural-patterns on Negentropy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 07 May 2021 20:15:00 +0800</lastBuildDate><atom:link href="https://chengyayu.github.io/tags/structural-patterns/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Facade Design Pattern</title>
      <link>https://chengyayu.github.io/posts/facade-design-pattern/</link>
      <pubDate>Fri, 07 May 2021 20:15:00 +0800</pubDate>
      
      <guid>https://chengyayu.github.io/posts/facade-design-pattern/</guid>
      <description>门面（外观）模式（Facade Design Pattern）是一种结构型设计模式。意图隐藏底层系统的复杂性，并为客户端提供一个简单的操作界面。
它为系统中许多底层接口提供了统一的接口，因此从客户端的角度来看，它更易于使用。 基本上，它在复杂的系统上提供了更高级别的抽象。
这也正式依赖注入思想的践行方式。
UML Diagram  InternalSubsystem x 为底层系统，有其独有的一套操作接口 Facade 为抽象出的外观结构，持有多个底层系统实例，并对外公开更简洁的操作接口  Example Question:
设计一个电子钱包系统，支持一下功能： - 检查账户 - 检查安全码 - 借记/贷记余额 - 账簿录入 - 发送消息通知 Code:
walletFacade.go: 电子钱包门面模块
package main import &amp;#34;fmt&amp;#34; type walletFacade struct { account *account wallet *wallet securityCode *securityCode notification *notification ledger *ledger } func newWalletFacade(accountID string, code int) *walletFacade { fmt.Println(&amp;#34;Starting create account&amp;#34;) walletFacacde := &amp;amp;walletFacade{ account: newAccount(accountID), securityCode: newSecurityCode(code), wallet: newWallet(), notification: &amp;amp;notification{}, ledger: &amp;amp;ledger{}, } fmt.</description>
    </item>
    
    <item>
      <title>Decorator Design Pattern</title>
      <link>https://chengyayu.github.io/posts/decorator-design-pattern/</link>
      <pubDate>Thu, 22 Apr 2021 13:28:06 +0800</pubDate>
      
      <guid>https://chengyayu.github.io/posts/decorator-design-pattern/</guid>
      <description>修饰器模式（Decorator Design Pattern）是一种结构型设计模式。意图动态地为原始对象添加一层层附加能力，以完成对原始对象既有功能的扩展和增强。
具体的修饰器应该遵循一个契约：持有 A 接口的实例，同时本身必须实现 A 接口。 由于目标实例和修饰器遵循同一接口，因此可用修饰器来对实例进行无限次的封装。结果实例将获得所有封装器叠加而来的行为。
目标对象可以是一个结构，也可以是一个函数。与之相对,可以分别通过结构组合（面向对象编程范式）或者高阶函数（函数式编程范式）的方式实现这个模式。
UML Diagram  Client 为主调方，依赖 Component 接口； Concrete Component 是实现了 Component 接口的结构； Decorator 定义了实现契约的“抽象类”：  修饰器必须内嵌一个实现了 Component 接口的实例 修饰器本身必须实现 Component 接口   Concrete Decorator 1(2) 是遵循 Decorator 契约的结构；  修饰器模式也是一种 Wrapper 模式，使用这种设计模式可以很方便得实现“俄罗斯套娃”，完成对既有功能的扩展增强。
Example 1 （面向对象编程范式） Go 实现的版本是通过组合玩法，创建内嵌 Component 实例的 Decorator 结构（本身也实现 Component 接口），来完成对既有接口的包装和扩展。
Question:
香河肉饼准备拓展业务卖披萨饼，暂定 原味饼底 10 元， Cocoa 配料 20 元， Fruit 配料 25 元， 饼底和口味(可叠加)随意组合，应如何设计？ Code:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  package main import &amp;#34;fmt&amp;#34; type IPizza interface { getTaste() []string getPrice() int } type Crepes struct{} func (p *Crepes) getTaste() []string { return []string{&amp;#34;default&amp;#34;} } func (p *Crepes) getPrice() int { return 10 } // Topping 是一个实现了 IPizza 的 decorator type Topping struct { pizza IPizza // 内嵌一个 IPizza 实例 	taste string price int } // WithTopping 通过不同参数创建不同 concrete decorator func WithTopping(pizza IPizza, taste string, price int) *Topping { return &amp;amp;Topping{pizza: pizza, taste: taste, price: price} } func (t *Topping) getTaste() []string { result := t.</description>
    </item>
    
    <item>
      <title>Adapter Design Pattern</title>
      <link>https://chengyayu.github.io/posts/adapter-design-pattern/</link>
      <pubDate>Tue, 20 Apr 2021 20:49:46 +0800</pubDate>
      
      <guid>https://chengyayu.github.io/posts/adapter-design-pattern/</guid>
      <description>适配器模式（Adapter Design Pattern）是一种结构型设计模式。意图把一个结构的一组方法转换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法一起工作的两个结构能够一起工作。对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。
UML Diagram  Client 为主调方，依赖 Target 接口; Target 表示目标接口定义; Adaptee 为一组不兼容 Target 接口定义的接口（被适配的结构）; Adaptor 将 Adaptee 转化成一组符合 Target 接口定义的接口;  适配器模式也可以称为 Wrapper 模式，通过构建（内嵌一个接口不匹配的 Adaptee）Wrapper 结构来对 Adaptee 进行能力转换以实现 Target 接口。由于 Client 的业务逻辑依赖的是抽象（Target 接口）而非具体的结构类型，原本无法与 Client 对接的 Adaptee 经过 Adapter 包装也可以与 Client 对接了。
Example Question：
mac 电脑具备接入 Lightning 插头的能力。 windows 电脑具备接入 USB 插头的能力。 client 希望将 Lightning 插头接入两台电脑，应如何处理？ Code:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  package main import &amp;#34;fmt&amp;#34; // 主调方依赖的目标接口 type computer interface { insertIntoLightningPort() } // 已实现目标接口 type mac struct{} func (m *mac) insertIntoLightningPort() { fmt.</description>
    </item>
    
    <item>
      <title>Proxy Design Pattern</title>
      <link>https://chengyayu.github.io/posts/proxy-design-pattern/</link>
      <pubDate>Mon, 19 Apr 2021 19:57:02 +0800</pubDate>
      
      <guid>https://chengyayu.github.io/posts/proxy-design-pattern/</guid>
      <description>代理模式（Proxy Design Pattern）是一种结构型设计模式。意图为主对象提供额外的一层（代理）以控制对这个对象的访问。
也是一种 Wrapper 设计模式，与修饰器模式代码结构相似，但是意图不同。
UML Diagram  Client 为主调方，依赖 Subject 接口； Subject 表示抽象主题，Proxy 和 RealSubject 都需要实现该接口； RealSubject 表示实现 Subject 接口的主题结构，负责主要业务逻辑； Proxy 表示实现 Subject 接口的代理结构，持有 RealSubject 对象，控制着外部对 RealSubject 对象的请求；  Example Question:
type server interface { handleRequest(string, string) (int, string) } 应用服务器 AppServer 满足 server 接口。 如何为 AppServer 设计一个代理，对 handleRequest 接口进行流量控制？ Code:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  package main import &amp;#34;fmt&amp;#34; type server interface { handleRequest(string, string) (int, string) } type nginx struct { appServer *appServer maxAllowedRequest int rateLimiter map[string]int } func newNginxServer() *nginx { return &amp;amp;nginx{ appServer: &amp;amp;appServer{}, maxAllowedRequest: 2, rateLimiter: make(map[string]int), } } func (n *nginx) handleRequest(url, method string) (int, string) { allowed := n.</description>
    </item>
    
  </channel>
</rss>
